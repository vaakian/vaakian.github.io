<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Frontends on Study Notes</title><link>https://note.vaakian.com/frontend/</link><description>Recent content in Frontends on Study Notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 27 Aug 2022 00:14:17 +0800</lastBuildDate><atom:link href="https://note.vaakian.com/frontend/index.xml" rel="self" type="application/rss+xml"/><item><title>TypeScript: Three Ways of Overloading</title><link>https://note.vaakian.com/frontend/three-ways-of-overloading/</link><pubDate>Sat, 27 Aug 2022 00:14:17 +0800</pubDate><guid>https://note.vaakian.com/frontend/three-ways-of-overloading/</guid><description>Definition overload means to provide multiple definitions for a function with the same name but different signatures. In TypeScript, we have three ways to achieve this.
1. multiple function definitions function sum(a: number): number; function sum(a: number, b: number): string; // actual implementation function sum(a: any, b?: any) { // do something } 2. Generic function sum&amp;lt;Args extends any[]&amp;gt;(...args: Args): Args[&amp;#39;length&amp;#39;] extends 1 ? number : string; // actual implementation function sum(a: any, b?</description></item><item><title>write a simple Vite plugin</title><link>https://note.vaakian.com/frontend/vite-plugin/</link><pubDate>Tue, 10 May 2022 14:50:32 +0800</pubDate><guid>https://note.vaakian.com/frontend/vite-plugin/</guid><description>prerequisites 在 webpack 中，分为 plugin 和 loader，其中 loader 的职责被划分为单一的翻译转换。 而在 vite 中，去除了 loader 的概念，而是将代码转换/编译的概念统一放到了 plugin 中去。
plugin vite: using plugin
目的 理解最基本的 plugin 概念，并为 vite 编写一个最简单的 plugin。
任务：创建一个 plugin 将以下文件进行编译，并实现import 文件：hello.wj
{ &amp;#34;name&amp;#34;: &amp;#34;John&amp;#34;, &amp;#34;age&amp;#34;: 12 } ---- &amp;lt;div&amp;gt;{ name }&amp;lt;/div&amp;gt; &amp;lt;div style=&amp;#34;color: green; font-size: 24px;&amp;#34;&amp;gt;{ age }&amp;lt;/div&amp;gt; 编译为
&amp;lt;div&amp;gt;John&amp;lt;/div&amp;gt; &amp;lt;div style=&amp;#34;color: green; font-size: 24px;&amp;#34;&amp;gt;12&amp;lt;/div&amp;gt; 在 js 文件中引入
import content from &amp;#39;./hello.wj&amp;#39;; console.log(content); /* &amp;lt;div&amp;gt;John&amp;lt;/div&amp;gt; &amp;lt;div style=&amp;#34;color: green; font-size: 24px;&amp;#34;&amp;gt;12&amp;lt;/div&amp;gt; */ 实现 在 vite 中，plugin 接受一个对象，包含很多属性，这里用到name和transform，transform 是一个函数，接受 code（文件内容）和 id（文件绝对路径）。如果 transform 返回值不为空，则这时候将返回的值作为编译后的代码，否则将返回原始的 code。</description></item><item><title>Creating a Function and it's prototype</title><link>https://note.vaakian.com/frontend/prototype/</link><pubDate>Tue, 19 Apr 2022 15:48:02 +0800</pubDate><guid>https://note.vaakian.com/frontend/prototype/</guid><description>简单回顾 prototype prototype 可以作为实例之间共享数据的一块空间。所以往 prototype 上放置任何属性，都可以被所有实例访问到。
function Animal() { // this是实例本身 console.log(this.name); } Animal.prototype.name = &amp;#39;Animal&amp;#39;; Animal.prototype.greet = function () { console.log(`hello, i am ${this.name}`); }; const cat = new Animal(); const dog = new Animal(); (cat.__proto__ === Animal.prototype) === dog.__proto__; 当通过实例本身访问任何属性，其过程为：自身 =&amp;gt; __proto__ =&amp;gt; __proto__ 的 __proto__ =&amp;gt; null
所以
const dog = new Animal(); // 相等 (dog.greet === Animal.prototype.greet) === dog.__proto__.greet; 但如果将构造函数改为
function Animal() { this.greet = function () { console.</description></item><item><title>TypeScript: Covariance &amp; Contravariance</title><link>https://note.vaakian.com/frontend/covariance-and-contravariance/</link><pubDate>Fri, 15 Apr 2022 13:36:51 +0800</pubDate><guid>https://note.vaakian.com/frontend/covariance-and-contravariance/</guid><description>个人复习用，不做科普。
创建两个类，Dog是Animal的子类。
class Animal {} class Dog extends Animal { bark() {} } 实现一个判断类型的Type，判断T是否是U的子类。
type Assignable&amp;lt;T, U&amp;gt; = T extends U ? true : false 测试，符合结果。
type R4 = Assignable&amp;lt;Dog, Animal&amp;gt; // true 但将同样的问题放到函数的parameters上，就发生了与第一直觉不一样的情况。
type ConsumeAnimal = (target: Animal) =&amp;gt; Animal type ConsumeDog = (target: Dog) =&amp;gt; Dog type R1 = Assignable&amp;lt;Son, Father&amp;gt; // false type R2 = Assignable&amp;lt;Father, Son&amp;gt; // true type R3 = Assignable&amp;lt;Parameters&amp;lt;Son&amp;gt;, Parameters&amp;lt;Father&amp;gt;&amp;gt; // true 问题出在哪里？ 通过Google，找到两个关键词：covariance和contravariance</description></item><item><title>React18: useDeferredValue</title><link>https://note.vaakian.com/frontend/react18-usedeferredvalue/</link><pubDate>Wed, 13 Apr 2022 12:24:53 +0800</pubDate><guid>https://note.vaakian.com/frontend/react18-usedeferredvalue/</guid><description>useDeferredValue的功能 &amp;amp; 场景 想象一个非常耗时的组件SlowComponent，当每次重新渲染时，在渲染结束之前，整个JavaScript主线程被阻塞(block)，无法处理任何事件，处于假死状态。
所以以下的input在输入新的值时，需要等到所有组件被render，input框才会更新显示新的值。
而SlowComponent耗时大约1s才返回结果，所以从键盘输入 =&amp;gt; 到页面上显示结果，需要等待1s。
包括input输入框。
function App() { const [text, setText] = useState(&amp;#34;hello&amp;#34;) return ( &amp;lt;div className=&amp;#34;App&amp;#34;&amp;gt; &amp;lt;input value={text} onChange={e =&amp;gt; setText(e.target.value)} /&amp;gt; {/* SlowComponent组件非常耗时 */} &amp;lt;SlowComponent text={text} /&amp;gt; &amp;lt;/div&amp;gt; ) } // 通过React.memo优化，text不变时，返回缓存的渲染结果。 const SlowComponent = React.memo(({ text }) =&amp;gt; { const now = Date.now() while (Date.now() - now &amp;lt; 500) { // do nothing } return &amp;lt;div&amp;gt;{text}&amp;lt;/div&amp;gt; }) 在线测试，改变1次输入框，输入框需要在500ms后响应。
https://codesandbox.io/s/goofy-khayyam-3q410q?file=/src/App.js
那么可不可以先立刻渲染出input，再去渲染SlowComponent呢？
答案是可以的，将「渲染过程」从上面的1次，分成2次。
怎么分？就是useDeferredValue可以用到的场景：</description></item><item><title>Nginx Reverse Proxy Path</title><link>https://note.vaakian.com/frontend/nginx-reverse-proxy-path/</link><pubDate>Tue, 12 Apr 2022 15:16:09 +0800</pubDate><guid>https://note.vaakian.com/frontend/nginx-reverse-proxy-path/</guid><description>假设服务器域名为vaakian.com，访问uri为http://vaakian.com/api/user，对比以下反向代理的效果。
1. 结尾都不打斜杠/ location /api { proxy_pass http://127.0.0.1:8080 } 反代结果
http://127.0.0.1:8080/api/user 2. location 打斜杠，proxy_pass 不打 location /api/ { proxy_pass http://127.0.0.1:8080 } 反代结果
http://127.0.0.1:8080/api/user 所以，如果 proxy_pass 不打斜杠，那么实际访问的路由部分是原封不动的拼接的。
2. location 不打，proxy_pass 打斜杠 location /api { proxy_pass http://127.0.0.1:8080/ } 反代结果，
http://127.0.0.1:8080//user 2. location 和 proxy_pass 都打斜杠 location /api/ { proxy_pass http://127.0.0.1:8080/ } 反代结果，
http://127.0.0.1:8080/user 所以，proxy_pass 打斜杠时实际匹配到的 location 会被清楚掉。</description></item><item><title>React18: concurrent rendering</title><link>https://note.vaakian.com/frontend/react18/</link><pubDate>Tue, 12 Apr 2022 14:56:18 +0800</pubDate><guid>https://note.vaakian.com/frontend/react18/</guid><description>React18更新了什么？ 最大的更新就是并发渲染(concurrent rendering)特性了。这里将同步渲染和并发渲染进行对比，以及了解和测试它所影响的视觉行为。
其次，使用react18，渲染方式有小的变动如下：
before
import React from &amp;#39;react&amp;#39; import ReactDOM from &amp;#39;react-dom&amp;#39; import &amp;#39;./index.css&amp;#39; import App from &amp;#39;./App&amp;#39; ReactDOM.render( &amp;lt;React.StrictMode&amp;gt; &amp;lt;App /&amp;gt; &amp;lt;/React.StrictMode&amp;gt;, document.getElementById(&amp;#39;root&amp;#39;) ) after
import { React } from &amp;#39;react&amp;#39; import { createRoot } from &amp;#39;react-dom/client&amp;#39; import &amp;#39;./index.css&amp;#39; import App from &amp;#39;./App&amp;#39; const root = createRoot(document.getElementById(&amp;#39;root&amp;#39;)) root.render(&amp;lt;App /&amp;gt;) 并发渲染 vs 同步渲染 在同步渲染过程中，每个组件所访问的外部资源都能够保证一致，因为render是一个大的任务。在这个任务完成之前，所有的任务都会被阻塞，包括页面。如果进行一个很重的渲染工作，在完成渲染之前，页面就会卡住无响应。
而并发渲染则不同，一个render可以被拆分成多个片段，在这个期间可以页面可以继续响应，不会卡死。但同时也带来了新的问题：如果某一次渲染的组件A，B访问了同一个外部资源，而这个资源在A渲染后被更改，然后B再渲染，就导致了视觉上的不一致(visual inconsistent)，不符合直觉。
例子对比 并发渲染(concurrent rendering)体现在API上就是通过startTransition来触发setter函数。
这里通过一个在页面上显示鼠标位置的实验，来更加清晰的展示这种情况。
当点击increment时，手动使页面重新渲染，然后更新页面x的值。
import { useState, useCallback, useEffect, useRef, startTransition } from &amp;#39;react&amp;#39; import &amp;#39;.</description></item><item><title>创建一个最简单的类Vue响应式数据</title><link>https://note.vaakian.com/frontend/mini-reactive-property/</link><pubDate>Fri, 25 Mar 2022 13:02:55 +0800</pubDate><guid>https://note.vaakian.com/frontend/mini-reactive-property/</guid><description>依赖管理 每个属性通过Dep类管理依赖，当属性变更，则通过Dep.notify()通知依赖项更新。
class Dep { subs = [] addSub(sub) { this.subs.push(sub) } notify() { this.subs.forEach(sub =&amp;gt; sub()) } off() { this.subs = [] } } module.exports = Dep 收集依赖 通过执行更新函数watcherFn，触发getter，此时收集到依赖函数watcherFn。依赖管理类Dep在getter中创建，如果没有依赖（即没有在watcherFn存在时触发getter），那就不会创建Dep对象，相对高效，节省资源。
处理computed属性 初始化时，执行computed函数，触发getter，收集相关依赖。 将每个computed的返回值也作为一个属性放到最终的代理属性上，并且与data同级别收集依赖。
const Dep = require(&amp;#39;./Dep&amp;#39;) // 暂存访问函数 let watcherFn // 依赖收集过程：暂存 =&amp;gt; 执行，访问属性，被收集 =&amp;gt; 清除 const watcher = (fn) =&amp;gt; { watcherFn = fn watcherFn() watcherFn = null } function Vue({ data, computed, watch }) { // 依赖管理类，每个属性key对应一个Dep对象 const deps = {} const instance = new Proxy(data, { get(target, key) { // 如果watcherFn不存在，则不是在收集依赖（不是通过watcher函数触发的），直接返回该值即可 if (watcherFn) { // 如果是watcherFn产生的get，才创建依赖。 // Warn：只有watcherFn产生的get才有意义 if (!</description></item><item><title>Implement async/await with generator/yield</title><link>https://note.vaakian.com/frontend/async-generator/</link><pubDate>Sun, 06 Mar 2022 14:11:03 +0800</pubDate><guid>https://note.vaakian.com/frontend/async-generator/</guid><description>async/await不是魔法，它只是一个语法糖，底层与生成器generator密不可分。 这里以学习为目的，简单用一个例子来模拟它们的行为，能够有一个直观的理解。
需要的前置知识，不再赘述：
ES6 async/await ES6 generator 创建一个异步加法函数 延迟1秒返回加法结果，方便实验。
function addAsync(x: number, y: number): Promise&amp;lt;number&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { setTimeout(() =&amp;gt; { resolve(x + y) }, 1000) }) } 实现单个yield（模拟await） function doAsync(g: () =&amp;gt; Generator): void { // 调用异步函数main，返回一个可迭代的iterator const it = g() // 调用next，运行到第一个yield之后暂停 const { value } = it.next() // 调用next则让yield之后的代码继续运行，并将v传递给yield作为返回值 value.then(v =&amp;gt; it.next(v)) } function* main() { const result: number = yield addAsync(5, 2) console.</description></item><item><title>Publish Ts Package</title><link>https://note.vaakian.com/frontend/publish-ts-package/</link><pubDate>Tue, 25 Jan 2022 17:37:56 +0800</pubDate><guid>https://note.vaakian.com/frontend/publish-ts-package/</guid><description> 草稿
由publish最近写的XPeer包引发的一系列新问题，记录学习所得。
XPeer是用TypeScript来写的，可以正常publish到npm上，但只能被ts项目所引用，而且需要反复编译，会浪费不少资源。
The 30-second guide to publishing a TypeScript package to NPM
预编译 tsc project 仅仅是将ts编译出原生js，前端项目能够直接import，不管是js还是ts项目。但不能通过浏览器&amp;lt;script&amp;gt;标签来引入。
browserify browserify能够对js进行bundle操作，让浏览器能够直接引入。至于什么是bundle？ tinify是browserify的压缩package，可以让bundle瘦身。 browserify-global-shim让某个包可以在windiw对象上全局访问。
配置 publish流程 npm init 配置package.json &amp;ldquo;main&amp;rdquo;: &amp;ldquo;lib/index.js&amp;rdquo;,即import的默认入口 &amp;ldquo;types&amp;rdquo;: &amp;ldquo;lib/index.d.ts&amp;rdquo;, 待考察 &amp;ldquo;exclude&amp;rdquo; &amp;ldquo;include&amp;rdquo; &amp;ldquo;declaration&amp;rdquo; 如何管理d.ts文件和types属性，让引包用户能够正常拿到type？
npm login
npm publish
使用 npm i -s xpeer
import { XPeer } from &amp;#39;xpeer&amp;#39; 总结</description></item><item><title>WebRTC: Signaling Server</title><link>https://note.vaakian.com/frontend/webrtc-signaling-server/</link><pubDate>Fri, 21 Jan 2022 21:20:40 +0800</pubDate><guid>https://note.vaakian.com/frontend/webrtc-signaling-server/</guid><description>Node.js服务端 服务端所需要做的事情：存储和广播房间信息 &amp;amp; 信令交换中介，包括sdp(SessionDescription)和ice(iceCandidate)。
接收基本的事件：join, offer, answer, icecandidate, leave
sdp用于协商会话连接方式之前的必要信息 ice协商的结果，用于候选的连接方式 客户端”仅在“join时带上id和nick，然后服务器存储该信息与Client对应。存储方式见：how to keep track of clients with WebSockets，或者直接在server.clients中挂载信息。
在offer和answer时，服务器取出对应的id和nick转发出去。
offer一定是广播，通过server.clients.forEach发送 answer是定向发送，带有receiverId，通过clientsMap发送 client对应表
class ClientsMap { constructor(server) { this.clients = new Map() server.on(&amp;#39;connection&amp;#39;, (ws, req) =&amp;gt; { ws.on(&amp;#39;message&amp;#39;, (message) =&amp;gt; { const data = JSON.parse(message) if (data.type === &amp;#39;join&amp;#39;) { this.clients.set(data.id, { id: data.id, nick: data.nick, ws: ws }) // 加入时，先注册好离开事件 ws.on(&amp;#39;close&amp;#39;, () =&amp;gt; { this.</description></item><item><title>TypeScript</title><link>https://note.vaakian.com/frontend/typescript/</link><pubDate>Fri, 21 Jan 2022 21:15:58 +0800</pubDate><guid>https://note.vaakian.com/frontend/typescript/</guid><description>动态属性 对象动态属性 即某个对象的属性类型 依赖于 另外一个属性，当Message的type为offer时，payload的属性为RTCSessionDescriptionInit，而不是一个联合类型PeerInfo | RTCSessionDescriptionInit | RTCIceCandidateInit。
interface PeerInfo { id: string nick: string } interface PayloadMap { join: PeerInfo offer: RTCSessionDescriptionInit answer: RTCSessionDescriptionInit icecandidate: RTCIceCandidateInit // leave只有单接受情况，客户端不会主动发送。 leave: PeerInfo } type Message = { [K in keyof PayloadMap]: { type: K nick: string receiverId?: string | null // playload的类型取决于type的值 payload: PayloadMap[K] } }[keyof PayloadMap] 单拎出来这一段，其实是map出了多个类型，一个key对应一个类型。然后Message通过keyof PayloadMap来获取到一个联合类型。
const MessageTypeMap = { [K in keyof PayloadMap]: { type: K nick: string id: string receiverId?</description></item><item><title>WebRTC: Multi-RTCPeerCoonection</title><link>https://note.vaakian.com/frontend/multi-rtcpeercoonection/</link><pubDate>Fri, 21 Jan 2022 16:24:57 +0800</pubDate><guid>https://note.vaakian.com/frontend/multi-rtcpeercoonection/</guid><description>一）抛出问题 一个RTCPeerConnection只能对应另外一个RTCPeerCoonection，如果想要实现多人会议。那么需要统一管理多个RTCPeerConnection，任何本地数据都要广播到多个RTCPeerConnection中去。
二）职责分割 在通过纯原生的RTCPeerConnection实现双人一对一视频会议时，发现代码分隔时已经力不从心了。如何实现多人更需要一些明确的职责分割。
管理多个PeerConnection 将本地数据广播到多个PeerConnection *如何将PeerConnection与WebSocket中的Client绑定（如何识别身份） Track概念：管理多个Track到一个Stream中 本地Stream推到远程 2.1 如何识别身份 如何在WebSocket和PeerConnection建立连接过程中去确定身份，如何确定两者相关联？
首先要理清楚，建立连接的整个流程。然后找出应该在哪个阶段去进行身份确认。
加入房间，发送JoinRoom消息，带上自己的nick和id（唯一标识），服务器存储信息对应，回复房间Clients列表。 如果房间有人，发送Offer消息（带nick和id），服务器广播之后，其他人回复Answer消息（带个人信息和将要发往的id） 前端接收到Answer，将对应的PeerConnection与该id和nick对应。此后的连接就容易对应了。 peerConnection.createOffer() // 1. 创建offer .then(offer =&amp;gt; { return peerConnection.setLocalDescription(offer); }) .then(() =&amp;gt; { // 2. 发送offer（广播） return ws.send(JSON.stringify({ type: &amp;#39;offer&amp;#39;, nick: nick, id: id, sdp: peerConnection.localDescription })); }) .then(() =&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { // 3. 接收answer ws.onmessage = (event) =&amp;gt; { const data = JSON.</description></item><item><title>React Hooks</title><link>https://note.vaakian.com/frontend/react-hooks/</link><pubDate>Tue, 18 Jan 2022 14:47:17 +0800</pubDate><guid>https://note.vaakian.com/frontend/react-hooks/</guid><description>[TOC]
useMemo 千万不要把useMemo和React.memo混为一谈，两者都是根据依赖变化来缓存数据的。useMemo(fn, deps)参照第二个参数列表的变化返回新的数据，否则返回缓存的数据。而React.memo只会在组件的props变化时重新渲染该组件。
使用场景 有非常耗时的计算，比如以下例子中的expensiveComputation，每一次组件渲染，都会调用该函数，并且重新计算。但其实a和b并没有变化时，计算的值都是一样的，所以需要使用到useMemo将结果缓存下来，而无需重新计算。
function App() { const [a, setA] = useState(1) const [b, setB] = useState(2) // const value = expensiveComputation(a, b) const value = useMemo(() =&amp;gt; expensiveComputation(a, b), [a, b]) return &amp;lt;div&amp;gt;result: {value}&amp;lt;/div&amp;gt; }
- 任何**hook**的依赖为对象时，可能会遇到「字面上」相同，但不是同一个对象，所以会导致依赖判断错误。因为**hook**的依赖数组对比是浅层的对比，也就是 `===` 对比。因为每次渲染时，组件内的所有字面变量都会被重新创建，所以遇到对象应该要格外注意。 &amp;gt; 对象判定相等 ```js const obj = {count: 1} console.log(obj === obj) // true // 引用不一样，所以为false console.log({count: 1} === {count: 1}) // false 以下例子，effect中的依赖是对象，虽然a, b没有发生变化，obj的字面上看起来也没用变化。但是在每次渲染时，都会创建一个新的对象，该对象引用不一样，所以每次都会执行effect。</description></item><item><title>WebRTC: RTCPeerConncetion</title><link>https://note.vaakian.com/frontend/webrtc-connection/</link><pubDate>Sat, 15 Jan 2022 13:29:47 +0800</pubDate><guid>https://note.vaakian.com/frontend/webrtc-connection/</guid><description>论文草稿
what is WebRTC WebRTC(Web Real-Time Communication)是一个最先由Google发布的点对点（Peer-to-Peer）通信协议，目前已经被各大浏览器所内置，早期不同浏览器的API有细微差别，需要开发者手动做兼容。现在可以使用MDN所推荐的WebRTC adapter.js来解决兼容问题。
其次它不仅仅适用于浏览器，也可以在任何其它不同平台的应用程序中使用，只要符合WebRTC的规范即可。
信道建立流程 两个实体（Peer）要建立连接或者说信道之前，需要先进行一项最最重要的工作，即信令交换。它将两个实体的信息（包含IP地址、端口等等各种用于建立连接的必要信息）进行互相交换，双方拿到信息后建立独立的信道。此后，两个实体就可以通过信道进行通信了，无需再通过服务器进行数据传输。
两种通信方式的优缺点 点对点通信方式不同于传统的中心化通信方式，需要一台或者多台服务器进行数据转发或者存储，这样会导致服务器的带宽和计算压力增大，而当服务器的负载增加时，会进而导致整个系统的稳定性下降，一旦中心服务器宕机，所有用户的通信将全部中断。而如果采用点对点通信方式，省去了服务器中转存储环节，降低了各个实体之间依赖性。用户之间可以直接通过网络进行通信，某个实体中断仅仅影响它自身，这样既可以节省服务器的资源，又提高了系统的稳定性。
不过，点对点通信也有自身的缺点，由于视频会议属于多对多的连接，每个实体要和其它所有实体都建立连接，随着系统中实体的增加，单个实体的压力也会随之增加。而采用的中心服务器转发存储方式就不会出现这种问题， 每个实体只需要和中心服务器建立连接，中心服务器负责存储数据和转发数据到其它实体。
所以，在实体较少、传输数据量大、网络延迟要求更高的场景下，点对点通信方式比较适合，反之，中心服务器转发存储方式比较适合。
RTCPeerConnection RTCPeerConnection负责很多事情，包括：
信令处理（singal processing） 编解码（Codec handling） 点对点连接（P2P connection） 安全（Security） 流量控制（bandwidth management） …… RTC创建连接过程主要是通过一个信令服务器进行SDP信息交换，这个过程可以通过WebSocket进行，也可以通过HTTP进行，当然WebSocket最佳。
const conn = new SomeWebsocketConn() const pc = new RTCPeerConnection(null) function sendOffer(desc) { // 发送offer到服务器上 conn.send({type: &amp;#39;offer&amp;#39;, sdp: desc}) // .then(gotAnswer) } // 当成功创建offer时调用 pc.createOffer(gotOffer) function gotOffer(desc) { pc.setLocalDescription(desc) // 发送到服务器 sendOffer(desc) } // 当服务器返回answer时调用 conn.</description></item><item><title>Vue响应式原理</title><link>https://note.vaakian.com/frontend/vue-reactive/</link><pubDate>Fri, 14 Jan 2022 21:22:48 +0800</pubDate><guid>https://note.vaakian.com/frontend/vue-reactive/</guid><description>开始 众所周知，Vue的响应式实现方式有两种，在Vue2中通过「Object.defineProperty」重新定义属性的descriptor中的getter/setter实现来。而Vue3通过ES6的“新人”「Proxy」来实现。
Vue2：Object.defineProperty 网传：&amp;ldquo;Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；&amp;rdquo;
纠错： 为什么Vue2中不劫持数组？
数组的位置不固定，数量多变，正常对象key对应value一般不会变，但是如果数组删除了某个元素，比如第一个元素被删除或者头部增加一个元素，那么将导致后面所有的key对应value错位，如果6个元素，也就会触发5次set。
数组元素可能非常非常多，每个元素进行劫持有一定浪费，这可能是Evan you对性能的考虑。
Vue2将数组的7个变异方法进行了重写，也就是更改了Array原型上的方法达到劫持变化。
Vue2将对象新增属性/数组修改等操作，通过Vue.set来统一实现，这样其实是直接告诉Vue自己的set行为，即要新增/修改的属性名，然后重新劫持或者通知修改Deps[key].notify()，Vue2才可以监测到「新增数据/数组下标」的变化。
以下代码测试拦截数组会发生的情况
const arr = [1, 2, 3, 4, 5, 6] for (let key in arr) { let value = arr[key] Object.defineProperty(arr, key, { get() { console.log(`get: ${key}`) return value }, set(newValue) { console.log(`set: ${key}to ${newValue}`) return value = newValue } }) } arr[0] = 999 // 打印：set：0 to 999 arr[3] // 打印：get：3 arr.</description></item><item><title>React之：自定义hooks: useCamera</title><link>https://note.vaakian.com/frontend/usecamera/</link><pubDate>Tue, 14 Dec 2021 15:55:03 +0800</pubDate><guid>https://note.vaakian.com/frontend/usecamera/</guid><description>⚠️注：从老博客迁移，可能有排版问题。
尝试用浏览器API封装一个读取摄像头视频流的useCamera自定义hooks，一步一步优化，总结一下得到目前为止的最佳实践。 首先，摄像头读取API需要传入最基本的参数constraints，通过promise方式得到stream后会展示到video标签上，那么useCamera应该接受一个能够读取到video标签的参数，那么首选ref，得到如下第一版代码：
function useCamera(constraints, videoRef) { const storedStream = useRef(null) // 当stream改变时，创建新的stop函数 const stop = useCallback(() =&amp;gt; { storedStream.current.getTracks().forEach(track =&amp;gt; track.stop()) }, [storedStream.current]) // 当constraints/videoRef改变时，创建新的start函数 const start = useCallback(() =&amp;gt; { navigator.mediaDevices.getUserMedia(constraints) .then(stream =&amp;gt; { console.log(&amp;#39;setting stream&amp;#39;) videoRef.current.srcObject = stream storedStreamRef.current = stream }) .catch(err =&amp;gt; { console.error(err) }) }, [constraints, videoRef]) // constraints改变时，stop上一次的媒体流并重新请求 useEffect(() =&amp;gt; { start() return stop }, [constraints]) return [start, stop] } 然后在组件中调用创建的hooks，功能上运行正常。</description></item><item><title>Introduction</title><link>https://note.vaakian.com/frontend/introduction/</link><pubDate>Tue, 14 Jan 2020 20:09:20 +0800</pubDate><guid>https://note.vaakian.com/frontend/introduction/</guid><description>Getting Started 从很久很久以前就想记录下来日常的学习笔记（不是博客），但都无疾而终。从wordpress=&amp;gt;Notion=&amp;gt;github issue都感觉差点味道。
而之前感觉通过hexo or hugo这种编译型的静态部署来记录又太麻烦，但现在需要它们的可定制性，索性还是尝试用hugo来继续记录吧。
Why not hexo? written in Go, which it&amp;rsquo;s fast.
About me 主前端，不过其它的也都有接触， 对网络安全感兴趣，算是一名业余脚本小子， 2022本科应届生，即将入职某互联网大厂。</description></item></channel></rss>