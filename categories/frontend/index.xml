<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Frontend on Study Notes</title><link>https://note.vaakian.com/categories/frontend/</link><description>Recent content in Frontend on Study Notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 13 Apr 2022 12:24:53 +0800</lastBuildDate><atom:link href="https://note.vaakian.com/categories/frontend/index.xml" rel="self" type="application/rss+xml"/><item><title>React18: useDeferredValue</title><link>https://note.vaakian.com/frontend/react18-usedeferredvalue/</link><pubDate>Wed, 13 Apr 2022 12:24:53 +0800</pubDate><guid>https://note.vaakian.com/frontend/react18-usedeferredvalue/</guid><description>useDeferredValue的功能 &amp;amp; 场景 想象一个非常耗时的组件SlowComponent，当每次重新渲染时，在渲染结束之前，整个JavaScript主线程被阻塞(block)，无法处理任何事件，处于假死状态。
所以以下的input在输入新的值时，需要等到所有组件被render，input框才会更新显示新的值。
而SlowComponent耗时大约1s才返回结果，所以从键盘输入 =&amp;gt; 到页面上显示结果，需要等待1s。
包括input输入框。
function App() { const [text, setText] = useState(&amp;#34;hello&amp;#34;) return ( &amp;lt;div className=&amp;#34;App&amp;#34;&amp;gt; &amp;lt;input value={text} onChange={e =&amp;gt; setText(e.target.value)} /&amp;gt; {/* SlowComponent组件非常耗时 */} &amp;lt;SlowComponent text={text} /&amp;gt; &amp;lt;/div&amp;gt; ) } // 通过React.memo优化，text不变时，返回缓存的渲染结果。 const SlowComponent = React.memo(({ text }) =&amp;gt; { const now = Date.now() while (Date.now() - now &amp;lt; 500) { // do nothing } return &amp;lt;div&amp;gt;{text}&amp;lt;/div&amp;gt; }) 在线测试，改变1次输入框，输入框需要在500ms后响应。
https://codesandbox.io/s/goofy-khayyam-3q410q?file=/src/App.js
那么可不可以先立刻渲染出input，再去渲染SlowComponent呢？
答案是可以的，将「渲染过程」从上面的1次，分成2次。
怎么分？就是useDeferredValue可以用到的场景：</description></item><item><title>React18 updates</title><link>https://note.vaakian.com/frontend/react18/</link><pubDate>Tue, 12 Apr 2022 14:56:18 +0800</pubDate><guid>https://note.vaakian.com/frontend/react18/</guid><description>React18更新了什么？ 最大的更新就是并发渲染(concurrent rendering)特性了。这里将同步渲染和并发渲染进行对比，以及了解和测试它所影响的视觉行为。
其次，使用react18，渲染方式有小的变动如下：
before
import React from &amp;#39;react&amp;#39; import ReactDOM from &amp;#39;react-dom&amp;#39; import &amp;#39;./index.css&amp;#39; import App from &amp;#39;./App&amp;#39; ReactDOM.render( &amp;lt;React.StrictMode&amp;gt; &amp;lt;App /&amp;gt; &amp;lt;/React.StrictMode&amp;gt;, document.getElementById(&amp;#39;root&amp;#39;) ) after
import { React } from &amp;#39;react&amp;#39; import { createRoot } from &amp;#39;react-dom/client&amp;#39; import &amp;#39;./index.css&amp;#39; import App from &amp;#39;./App&amp;#39; const root = createRoot(document.getElementById(&amp;#39;root&amp;#39;)) root.render(&amp;lt;App /&amp;gt;) 并发渲染 vs 同步渲染 在同步渲染过程中，每个组件所访问的外部资源都能够保证一致，因为render是一个大的任务。在这个任务完成之前，所有的任务都会被阻塞，包括页面。如果进行一个很重的渲染工作，在完成渲染之前，页面就会卡住无响应。
而并发渲染则不同，一个render可以被拆分成多个片段，在这个期间可以页面可以继续响应，不会卡死。但同时也带来了新的问题：如果某一次渲染的组件A，B访问了同一个外部资源，而这个资源在A渲染后被更改，然后B再渲染，就导致了视觉上的不一致(visual inconsistent)，不符合直觉。
例子对比 并发渲染(concurrent rendering)体现在API上就是通过startTransition来触发setter函数。
这里通过一个在页面上显示鼠标位置的实验，来更加清晰的展示这种情况。
当点击increment时，手动使页面重新渲染，然后更新页面x的值。
import { useState, useCallback, useEffect, useRef, startTransition } from &amp;#39;react&amp;#39; import &amp;#39;.</description></item><item><title>创建一个最简单的类Vue响应式数据</title><link>https://note.vaakian.com/frontend/mini-reactive-property/</link><pubDate>Fri, 25 Mar 2022 13:02:55 +0800</pubDate><guid>https://note.vaakian.com/frontend/mini-reactive-property/</guid><description>依赖管理 每个属性通过Dep类管理依赖，当属性变更，则通过Dep.notify()通知依赖项更新。
class Dep { subs = [] addSub(sub) { this.subs.push(sub) } notify() { this.subs.forEach(sub =&amp;gt; sub()) } off() { this.subs = [] } } module.exports = Dep 收集依赖 通过执行更新函数watcherFn，触发getter，此时收集到依赖函数watcherFn。依赖管理类Dep在getter中创建，如果没有依赖（即没有在watcherFn存在时触发getter），那就不会创建Dep对象，相对高效，节省资源。
处理computed属性 初始化时，执行computed函数，触发getter，收集相关依赖。 将每个computed的返回值也作为一个属性放到最终的代理属性上，并且与data同级别收集依赖。
const Dep = require(&amp;#39;./Dep&amp;#39;) // 暂存访问函数 let watcherFn // 依赖收集过程：暂存 =&amp;gt; 执行，访问属性，被收集 =&amp;gt; 清除 const watcher = (fn) =&amp;gt; { watcherFn = fn watcherFn() watcherFn = null } function Vue({ data, computed, watch }) { // 依赖管理类，每个属性key对应一个Dep对象 const deps = {} const instance = new Proxy(data, { get(target, key) { // 如果watcherFn不存在，则不是在收集依赖（不是通过watcher函数触发的），直接返回该值即可 if (watcherFn) { // 如果是watcherFn产生的get，才创建依赖。 // Warn：只有watcherFn产生的get才有意义 if (!</description></item><item><title>Implement async/await with generator/yield</title><link>https://note.vaakian.com/frontend/async-generator/</link><pubDate>Sun, 06 Mar 2022 14:11:03 +0800</pubDate><guid>https://note.vaakian.com/frontend/async-generator/</guid><description>async/await不是魔法，它只是一个语法糖，底层与生成器generator密不可分。 这里以学习为目的，简单用一个例子来模拟它们的行为，能够有一个直观的理解。
需要的前置知识，不再赘述：
ES6 async/await ES6 generator 创建一个异步加法函数 延迟1秒返回加法结果，方便实验。
function addAsync(x: number, y: number): Promise&amp;lt;number&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { setTimeout(() =&amp;gt; { resolve(x + y) }, 1000) }) } 实现单个yield（模拟await） function doAsync(g: () =&amp;gt; Generator): void { // 调用异步函数main，返回一个可迭代的iterator const it = g() // 调用next，运行到第一个yield之后暂停 const { value } = it.next() // 调用next则让yield之后的代码继续运行，并将v传递给yield作为返回值 value.then(v =&amp;gt; it.next(v)) } function* main() { const result: number = yield addAsync(5, 2) console.</description></item><item><title>WebRTC: Multi-RTCPeerCoonection</title><link>https://note.vaakian.com/frontend/multi-rtcpeercoonection/</link><pubDate>Fri, 21 Jan 2022 16:24:57 +0800</pubDate><guid>https://note.vaakian.com/frontend/multi-rtcpeercoonection/</guid><description>一）抛出问题 一个RTCPeerConnection只能对应另外一个RTCPeerCoonection，如果想要实现多人会议。那么需要统一管理多个RTCPeerConnection，任何本地数据都要广播到多个RTCPeerConnection中去。
二）职责分割 在通过纯原生的RTCPeerConnection实现双人一对一视频会议时，发现代码分隔时已经力不从心了。如何实现多人更需要一些明确的职责分割。
管理多个PeerConnection 将本地数据广播到多个PeerConnection *如何将PeerConnection与WebSocket中的Client绑定（如何识别身份） Track概念：管理多个Track到一个Stream中 本地Stream推到远程 2.1 如何识别身份 如何在WebSocket和PeerConnection建立连接过程中去确定身份，如何确定两者相关联？
首先要理清楚，建立连接的整个流程。然后找出应该在哪个阶段去进行身份确认。
加入房间，发送JoinRoom消息，带上自己的nick和id（唯一标识），服务器存储信息对应，回复房间Clients列表。 如果房间有人，发送Offer消息（带nick和id），服务器广播之后，其他人回复Answer消息（带个人信息和将要发往的id） 前端接收到Answer，将对应的PeerConnection与该id和nick对应。此后的连接就容易对应了。 peerConnection.createOffer() // 1. 创建offer .then(offer =&amp;gt; { return peerConnection.setLocalDescription(offer); }) .then(() =&amp;gt; { // 2. 发送offer（广播） return ws.send(JSON.stringify({ type: &amp;#39;offer&amp;#39;, nick: nick, id: id, sdp: peerConnection.localDescription })); }) .then(() =&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { // 3. 接收answer ws.onmessage = (event) =&amp;gt; { const data = JSON.</description></item><item><title>React Hooks</title><link>https://note.vaakian.com/frontend/react-hooks/</link><pubDate>Tue, 18 Jan 2022 14:47:17 +0800</pubDate><guid>https://note.vaakian.com/frontend/react-hooks/</guid><description>[TOC]
useMemo 千万不要把useMemo和React.memo混为一谈，两者都是根据依赖变化来缓存数据的。useMemo(fn, deps)参照第二个参数列表的变化返回新的数据，否则返回缓存的数据。而React.memo只会在组件的props变化时重新渲染该组件。
使用场景 有非常耗时的计算，比如以下例子中的expensiveComputation，每一次组件渲染，都会调用该函数，并且重新计算。但其实a和b并没有变化时，计算的值都是一样的，所以需要使用到useMemo将结果缓存下来，而无需重新计算。 function App() { const [a, setA] = useState(1) const [b, setB] = useState(2) // const value = expensiveComputation(a, b) const value = useMemo(() =&amp;gt; expensiveComputation(a, b), [a, b]) return &amp;lt;div&amp;gt;result: {value}&amp;lt;/div&amp;gt; } 任何hook的依赖为对象时，可能会遇到「字面上」相同，但不是同一个对象，所以会导致依赖判断错误。因为hook的依赖数组对比是浅层的对比，也就是 === 对比。因为每次渲染时，组件内的所有字面变量都会被重新创建，所以遇到对象应该要格外注意。 对象判定相等
const obj = {count: 1} console.log(obj === obj) // true // 引用不一样，所以为false console.log({count: 1} === {count: 1}) // false 以下例子，effect中的依赖是对象，虽然a, b没有发生变化，obj的字面上看起来也没用变化。但是在每次渲染时，都会创建一个新的对象，该对象引用不一样，所以每次都会执行effect。</description></item><item><title>WebRTC: RTCPeerConncetion</title><link>https://note.vaakian.com/frontend/webrtc-connection/</link><pubDate>Sat, 15 Jan 2022 13:29:47 +0800</pubDate><guid>https://note.vaakian.com/frontend/webrtc-connection/</guid><description>论文草稿
what is WebRTC WebRTC(Web Real-Time Communication)是一个最先由Google发布的点对点（Peer-to-Peer）通信协议，目前已经被各大浏览器所内置，早期不同浏览器的API有细微差别，需要开发者手动做兼容。现在可以使用MDN所推荐的WebRTC adapter.js来解决兼容问题。
其次它不仅仅适用于浏览器，也可以在任何其它不同平台的应用程序中使用，只要符合WebRTC的规范即可。
信道建立流程 两个实体（Peer）要建立连接或者说信道之前，需要先进行一项最最重要的工作，即信令交换。它将两个实体的信息（包含IP地址、端口等等各种用于建立连接的必要信息）进行互相交换，双方拿到信息后建立独立的信道。此后，两个实体就可以通过信道进行通信了，无需再通过服务器进行数据传输。
两种通信方式的优缺点 点对点通信方式不同于传统的中心化通信方式，需要一台或者多台服务器进行数据转发或者存储，这样会导致服务器的带宽和计算压力增大，而当服务器的负载增加时，会进而导致整个系统的稳定性下降，一旦中心服务器宕机，所有用户的通信将全部中断。而如果采用点对点通信方式，省去了服务器中转存储环节，降低了各个实体之间依赖性。用户之间可以直接通过网络进行通信，某个实体中断仅仅影响它自身，这样既可以节省服务器的资源，又提高了系统的稳定性。
不过，点对点通信也有自身的缺点，由于视频会议属于多对多的连接，每个实体要和其它所有实体都建立连接，随着系统中实体的增加，单个实体的压力也会随之增加。而采用的中心服务器转发存储方式就不会出现这种问题， 每个实体只需要和中心服务器建立连接，中心服务器负责存储数据和转发数据到其它实体。
所以，在实体较少、传输数据量大、网络延迟要求更高的场景下，点对点通信方式比较适合，反之，中心服务器转发存储方式比较适合。
RTCPeerConnection RTCPeerConnection负责很多事情，包括：
信令处理（singal processing） 编解码（Codec handling） 点对点连接（P2P connection） 安全（Security） 流量控制（bandwidth management） …… RTC创建连接过程主要是通过一个信令服务器进行SDP信息交换，这个过程可以通过WebSocket进行，也可以通过HTTP进行，当然WebSocket最佳。
const conn = new SomeWebsocketConn() const pc = new RTCPeerConnection(null) function sendOffer(desc) { // 发送offer到服务器上 conn.send({type: &amp;#39;offer&amp;#39;, sdp: desc}) // .then(gotAnswer) } // 当成功创建offer时调用 pc.createOffer(gotOffer) function gotOffer(desc) { pc.setLocalDescription(desc) // 发送到服务器 sendOffer(desc) } // 当服务器返回answer时调用 conn.</description></item><item><title>Vue响应式原理</title><link>https://note.vaakian.com/frontend/vue-reactive/</link><pubDate>Fri, 14 Jan 2022 21:22:48 +0800</pubDate><guid>https://note.vaakian.com/frontend/vue-reactive/</guid><description>开始 众所周知，Vue的响应式实现方式有两种，在Vue2中通过「Object.defineProperty」重新定义属性的descriptor中的getter/setter实现来。而Vue3通过ES6的“新人”「Proxy」来实现。
Vue2：Object.defineProperty 网传：&amp;ldquo;Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；&amp;rdquo;
纠错： 为什么Vue2中不劫持数组？
数组的位置不固定，数量多变，正常对象key对应value一般不会变，但是如果数组删除了某个元素，比如第一个元素被删除或者头部增加一个元素，那么将导致后面所有的key对应value错位，如果6个元素，也就会触发5次set。
数组元素可能非常非常多，每个元素进行劫持有一定浪费，这可能是Evan you对性能的考虑。
Vue2将数组的7个变异方法进行了重写，也就是更改了Array原型上的方法达到劫持变化。
Vue2将对象新增属性/数组修改等操作，通过Vue.set来统一实现，这样其实是直接告诉Vue自己的set行为，即要新增/修改的属性名，然后重新劫持或者通知修改Deps[key].notify()，Vue2才可以监测到「新增数据/数组下标」的变化。
以下代码测试拦截数组会发生的情况
const arr = [1, 2, 3, 4, 5, 6] for (let key in arr) { let value = arr[key] Object.defineProperty(arr, key, { get() { console.log(`get: ${key}`) return value }, set(newValue) { console.log(`set: ${key}to ${newValue}`) return value = newValue } }) } arr[0] = 999 // 打印：set：0 to 999 arr[3] // 打印：get：3 arr.</description></item><item><title>React之：自定义hooks: useCamera</title><link>https://note.vaakian.com/frontend/usecamera/</link><pubDate>Tue, 14 Dec 2021 15:55:03 +0800</pubDate><guid>https://note.vaakian.com/frontend/usecamera/</guid><description>⚠️注：从老博客迁移，可能有排版问题。
尝试用浏览器API封装一个读取摄像头视频流的useCamera自定义hooks，一步一步优化，总结一下得到目前为止的最佳实践。 首先，摄像头读取API需要传入最基本的参数constraints，通过promise方式得到stream后会展示到video标签上，那么useCamera应该接受一个能够读取到video标签的参数，那么首选ref，得到如下第一版代码：
function useCamera(constraints, videoRef) { const storedStream = useRef(null) // 当stream改变时，创建新的stop函数 const stop = useCallback(() =&amp;gt; { storedStream.current.getTracks().forEach(track =&amp;gt; track.stop()) }, [storedStream.current]) // 当constraints/videoRef改变时，创建新的start函数 const start = useCallback(() =&amp;gt; { navigator.mediaDevices.getUserMedia(constraints) .then(stream =&amp;gt; { console.log(&amp;#39;setting stream&amp;#39;) videoRef.current.srcObject = stream storedStreamRef.current = stream }) .catch(err =&amp;gt; { console.error(err) }) }, [constraints, videoRef]) // constraints改变时，stop上一次的媒体流并重新请求 useEffect(() =&amp;gt; { start() return stop }, [constraints]) return [start, stop] } 然后在组件中调用创建的hooks，功能上运行正常。</description></item></channel></rss>